* 《程序员修炼之道》－－从小工到大家
      + 能不能让正确的原则指导正确的行动本身，其实就是区分是否高手的一个显著标志。
      + 编程是一种技艺，一种需要 *用心学习的技艺* 。
      + 不应该局限于任何限定的技术，而是应该拥有足够广博的背景和经验基础，以让你能在特定情况下选择好的解决方案。你的背景源自于对计算机科学的基本原理的理解，而你的经验来自广泛的实际项目。
      + 注重实效的程序员不仅要完成工作，而且要完成得漂亮。
      + 软件构造应该是工程学科。但是，并不排斥个人的技艺。
      + 我们, 采集的只是石头，却必须时刻展望未来的大教堂。--采石工人的信条
      + 不间断的思考，实时地批判你的工作。
      + 在一个项目的总体结构中，总有 *个性* 和 *技艺* 的位置。
      + *注重实效* 的哲学
      + 越出直接的问题去思考，总是设法把问题放在更大的语境中，总是 *设法注意更大的图景* 。
      + 对自己做的每件事情 *负责* 。
      + 在所有弱电中， *最大的弱点就是害怕暴露弱点* 。
      + 一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感。
      + *要持续不断地观察周围发生变化的事情* ，而不只是你自己在做的事情。
      + 不要因为过度修饰和过于求精而毁损完好的程序。
      + 是否在某个项目中使用这些技术，或者是否把它们放入你的简历，这并不重要。 *学习的过程将扩展你的思维，使你向着新的可能性和新的做事方式扩展* 。
      + 所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片刻时间里总有东西可读。
      + 批判地思考你读到的和听到的。不要受到供应商或者媒体炒作的影响。
      + 编码
        - 让你的代码保持解耦
        - 避免使用全局数据
        - 避免编写相似的函数
      + 养成不断地 *批判* 对待自己的代码的习惯。寻找任何重新进行组织、以改善其结构和正交性的机会。
      + 要实现某种东西，总有不止一种方式，而且通常有不止一家供应商可以提供第三方产品。
      + 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了。
      + *如果你看到马蹄印，要想到马，而不是斑马* 。
      + 注重实效的程序员，连自己的代码也不信任。（注意这里不是不自信)没有人能编写完美的代码，针对自己的错误进行防卫性的编码。构建代码、对资源确实得到了适当释放进行实际检查。
      + 当每个人都确实要对你不利时，偏执就是一个好主意。 -- Woody Allen
      + 没有什么比常识和坦率更让人感到惊讶。
      + 死程序，不说谎。
      + 如果有一个错误，就说明非常、非常糟糕的事情已经发生了。
      + 不要用断言代替真正的错误处理。断言检查的是决不应该发生的事情。
      + 只要在编程，我们都要管理资源：内存、事务、线程、文件、定时器－－所有数量有限的事物。大多数时候，资源使用遵循一种可预测的模式：分配资源，使用它，然后解除其分配。
      + *保持灵活*
        - 少些代码
        - 降低耦合
        - 数据模型(model)和模型的视图(view)分离
        - 提供一个“聚会地点”，　各模块之间可以在那里匿名和异步地交换数据。
      + 好篱笆促成好邻居。
      + 切断最小组织单位之间的交往能保护每一个人。把代码组织成 *最小组织单位* （模块），并限制它们之间的交互。随后出于折中必须替换某个模块，其他模块仍能继续工作。
      + 为 *并发* 进行设计。
      + 不要写渡渡鸟代码。
      + 为一般情况写程序，把具体情况放在别处。
      + 动态配置。
      + 再多的天才也无法胜过对 *细节* 的专注。
      + 注重 *实效的程序员* 几乎每天都要使用：估计算法使用的资源--时间、处理器、内存，and so on.
      + 需要在选择适当算法时注重实效--最快的算法对于你的工作并非总是最好的。
      + 每个开发者都应该有 *设计与分析算法的才能* 。
      + 重写、重做和重新架构代码合起来，称为 *重构* 。重构是意向需要慎重、深思熟虑、小心进行的活动。进行利大于弊的重构：
        - 不要试图在重构的同时增加新功能。
        - 在开始重构之前，确保你拥有良好的测试。
        - 采取短小、深思熟虑的步骤。
      + 找出用户为何要做特定事情的 *原因* 、而不只是他们目前做这件事情的方式，这很重要。到最后，你的开发必须解决他们的商业问题，而不只是满足他们陈述的需求。用文档记载需求背后的原因将在每天进行实现决策时给你的团队带来无价的信息。
      + 在项目启动之前把这些关键问题解决好，你就能更好地避免“分析瘫痪”（analysis paralysis）, 并实际开始你的成功项目。
      + 完美，不是在没有什么需要增加、而是在没有什么需要去掉时达到的。
      + 成功的工具会适应使用他们的双手。
      + 真正的用例是具有层次结构和交叉链接的文字描述。
      + 需求不是架构。需求不是设计，也不是用户界面。需求是需要。
      + 在面对棘手的问题时，列出所有你面前的 *可能途径* 。不要排除任何东西，不管它听起来有多无用活愚蠢。列出检查列表中的每一项，并解释为何不能采用某个特定的途径。
      + 先确定最为严格的约束。然后再考虑其余的约束。
      + *编写程序规范* 就是把需求归约到程序员能够接管的程度的过程。这是一个交流活动，旨在解释并澄清系统的需求，比如消除主要的歧义。除了与最初实现的开发者交谈以外，规范还是留给未来进行代码维护和增强的几批程序员的记录。规范也是与用户的约定。
      + 倾向于把需求、设计、以及实现视为同一个过程--交付高质量的系统--的不同方面。要设法采用无缝的方法：规范和实现不过是同一个过程--设法捕捉和编撰需求--的不同方面。
      + 把 *技术* 和 *方法* 放进开发实践和能力的语境中。
      + *批判地看待方法学* ，并从各种方法学中提取精华，融合成每个月都在变得更好的一套工作习惯。不断努力提炼和改善你的开发过程。绝不要把方法学的呆板限制当做你的世界的边界。
      + 测试什么
        - 单元测试
        - 集成测试
        - 验证和校验
        - 资源耗尽、错误及恢复
        - 性能测试
        - 可用性测试
        - 等等
      + 把文档当作整个开发过程的完整组成部分加以接受。不进行重复劳动，不浪费时间，并且把文档放在手边－－如果可能就放在代码本身当中，文档的撰写就可以变得更容易。
      + 代码已经说明了它是怎样完成的。注释应该讨论为何要做某事、它的目的和目标。
        - 简单的模块级头注释
        - 关于重要数据于类型声明的注释
        - 给每个类和每个方法所加的简要头注释
        - 用以描述函数的方法和任何不明了的事情
        - 变量名应该精心选择，并且有意义
      + 要设法让你的用户惊讶。但注意，不是惊吓他们，而是要让他们高兴。给他们的东西要比他们期望的多一点。（这个是否是乌合之众的心理学里面的观点？是否迎合了老板对广大下属员工、将领对士兵们居高临下的心态？）
      + 你愉悦我们已经足够长久。－－《傲慢与偏见》
      + 不会逃避责任。乐于接受挑战，乐于分享，乐于使我们的专业知识广为人知。（这样哪怕出错，就会有人帮忙指正）
      + 一个 *注重实效的程序员*
      + tips:
        - Crash Early.(早崩溃。)
        - Test early. Test Often. Test Automatically.
        - Code Ain't Done 'Til All the Tests Run.(要到通过全部测试，编码才算完成。)
        - Use Saboteurs to Test Your Testing. (通过“蓄意破坏”测试你的测试)
        - Test State Coverage, Not Code Coverage.(测试状态覆盖，而不是代码覆盖)
        - Find Bugs Once (一个 bug 只抓一次)
        - Treat English as just Another Programmiing Language.(把英语当作又一种编程语言。)
        - Build Documentation In, Don't Bolt It On.(大概意思是：应该把文档建在代码内部，而不是硬扣挂上去。)
        - Don't Be a Slave to Formal Method.
        - Expensive Tools Do Not Produce Better Designs.
        - Organize Around Functionality, Not Job Functions.
        - Care About Your Craft.(关注你的技艺。)
        - Don't Assume it - Prove It.(不要假定，要证明。)
        - Learn a Text Manipulation Language.(学习一种文本操纵语言。)
        - Think!About Your Work.(思考！你的工作。)
        - Provide Options, Don't Make Lame Excuses.(提供各种选择，不要找蹩脚的借口。)
        - Don't Live with Broken Windows.(不要容忍破窗户)
        - Be a Catalyst for Change. (做变化的催化剂)
        - Remember the Big Picture.(记住大的图景)
        - Invest Regularly in Your Knowledge Portfolio.(定期为你的知识资产投资)
        - Critically Analyze What You Read and Hear.(批判地分析你读到的和听到的)
        - DRY - Don't Repeat Yourself.(不要重复你自己)
        - Make It Easy to Reuse.(让复用变得容易)
        - Eliminate Effects Between Unrelated Things.(消除无关事物之间的影响)
        - Write Code That Writes Code.(编写能编写代码的代码。)
        - You Can't Write Perfect Software.(你不可能写出完美的软件。)
        - If It Can't Happen, Use Assertions to Ensure That it Won't. (如果它不可能发生, 用断言确保它不会发生。)
        - Finish What You Start.
        - Don't Program by Coincidence.
        - Use Blackboards to Coordinate Workflow.
        - Separate Views from Models.
        - Design Using Services.
        - Analyze Workflow to Improve Concurrency.
        - Put Abstractions in Code, Details in Metadata. (将抽象放进代码， 细节放进元数据。)
        - Configure, Don't Integrate.(要配置，不要集成。)
        - Estimate the Order Your Algorithms.(估算你的算法的阶。)
        - Test Your Estimates.
        - Design to Test.
        - Test Your Software, or Your Users Will.
        - Don't Use Wizard Code You Don't Understand.
        - Refactor Early, Refactor Often.(早重构，常重构。)
        - Work with a User to Think Like a User.(与用户一起工作，像用户一样思考)
        - Abstractions Live Longer than Details.(抽象比细节活得更长久。)
        - Use a Project Glossary.
        - Don't Think Outside the Box-Find the Box.
        - Listen to Nagging Doubts-Start When You're Ready.
        - Some Things Are Better Done than Described.
        - Gently Exceed Your Users'Expectations.(温和地超出用户的期望)
        - Sign Your Work.
